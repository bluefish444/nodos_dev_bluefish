// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_BLUEFISHTYPES_BLUEFISH444_H_
#define FLATBUFFERS_GENERATED_BLUEFISHTYPES_BLUEFISH444_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 5 &&
              FLATBUFFERS_VERSION_REVISION == 26,
             "Non-compatible flatbuffers version included");

#include "array"

namespace bluefish444 {

struct DeviceId;
struct DeviceIdBuilder;
struct TDeviceId;

struct ChannelId;
struct ChannelIdBuilder;
struct TChannelId;

struct ChannelInfo;
struct ChannelInfoBuilder;
struct TChannelInfo;

bool operator==(const TDeviceId &lhs, const TDeviceId &rhs);
bool operator!=(const TDeviceId &lhs, const TDeviceId &rhs);
bool operator==(const TChannelId &lhs, const TChannelId &rhs);
bool operator!=(const TChannelId &lhs, const TChannelId &rhs);
bool operator==(const TChannelInfo &lhs, const TChannelInfo &rhs);
bool operator!=(const TChannelInfo &lhs, const TChannelInfo &rhs);

inline const ::flatbuffers::TypeTable *DeviceIdTypeTable();

inline const ::flatbuffers::TypeTable *ChannelIdTypeTable();

inline const ::flatbuffers::TypeTable *ChannelInfoTypeTable();

struct TDeviceId : public ::flatbuffers::NativeTable {
  typedef DeviceId TableType;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "bluefish444.TDeviceId";
  }
  std::string serial{};
  std::string name{};
};

struct DeviceId FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TDeviceId NativeTableType;
  typedef DeviceIdBuilder Builder;
  struct Traits;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return DeviceIdTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "bluefish444.DeviceId";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SERIAL = 4,
    VT_NAME = 6
  };
  const ::flatbuffers::String *serial() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SERIAL);
  }
  ::flatbuffers::String *mutable_serial() {
    return GetPointer<::flatbuffers::String *>(VT_SERIAL);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  ::flatbuffers::String *mutable_name() {
    return GetPointer<::flatbuffers::String *>(VT_NAME);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return serial();
    else if constexpr (Index == 1) return name();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SERIAL) &&
           verifier.VerifyString(serial()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           verifier.EndTable();
  }
  TDeviceId *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TDeviceId *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<DeviceId> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TDeviceId* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DeviceIdBuilder {
  typedef DeviceId Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_serial(::flatbuffers::Offset<::flatbuffers::String> serial) {
    fbb_.AddOffset(DeviceId::VT_SERIAL, serial);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(DeviceId::VT_NAME, name);
  }
  explicit DeviceIdBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DeviceId> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DeviceId>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<DeviceId> CreateDeviceId(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> serial = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0) {
  DeviceIdBuilder builder_(_fbb);
  builder_.add_name(name);
  builder_.add_serial(serial);
  return builder_.Finish();
}

struct DeviceId::Traits {
  using type = DeviceId;
  static auto constexpr Create = CreateDeviceId;
  static constexpr auto name = "DeviceId";
  static constexpr auto fully_qualified_name = "bluefish444.DeviceId";
  static constexpr size_t fields_number = 2;
  static constexpr std::array<const char *, fields_number> field_names = {
    "serial",
    "name"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

inline ::flatbuffers::Offset<DeviceId> CreateDeviceIdDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *serial = nullptr,
    const char *name = nullptr) {
  auto serial__ = serial ? _fbb.CreateString(serial) : 0;
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return bluefish444::CreateDeviceId(
      _fbb,
      serial__,
      name__);
}

::flatbuffers::Offset<DeviceId> CreateDeviceId(::flatbuffers::FlatBufferBuilder &_fbb, const TDeviceId *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TChannelId : public ::flatbuffers::NativeTable {
  typedef ChannelId TableType;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "bluefish444.TChannelId";
  }
  int32_t id = 0;
  std::string name{};
};

struct ChannelId FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TChannelId NativeTableType;
  typedef ChannelIdBuilder Builder;
  struct Traits;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ChannelIdTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "bluefish444.ChannelId";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_NAME = 6
  };
  int32_t id() const {
    return GetField<int32_t>(VT_ID, 0);
  }
  bool mutate_id(int32_t _id = 0) {
    return SetField<int32_t>(VT_ID, _id, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  ::flatbuffers::String *mutable_name() {
    return GetPointer<::flatbuffers::String *>(VT_NAME);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return id();
    else if constexpr (Index == 1) return name();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ID, 4) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           verifier.EndTable();
  }
  TChannelId *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TChannelId *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<ChannelId> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TChannelId* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ChannelIdBuilder {
  typedef ChannelId Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(int32_t id) {
    fbb_.AddElement<int32_t>(ChannelId::VT_ID, id, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(ChannelId::VT_NAME, name);
  }
  explicit ChannelIdBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ChannelId> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ChannelId>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ChannelId> CreateChannelId(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0) {
  ChannelIdBuilder builder_(_fbb);
  builder_.add_name(name);
  builder_.add_id(id);
  return builder_.Finish();
}

struct ChannelId::Traits {
  using type = ChannelId;
  static auto constexpr Create = CreateChannelId;
  static constexpr auto name = "ChannelId";
  static constexpr auto fully_qualified_name = "bluefish444.ChannelId";
  static constexpr size_t fields_number = 2;
  static constexpr std::array<const char *, fields_number> field_names = {
    "id",
    "name"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

inline ::flatbuffers::Offset<ChannelId> CreateChannelIdDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t id = 0,
    const char *name = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return bluefish444::CreateChannelId(
      _fbb,
      id,
      name__);
}

::flatbuffers::Offset<ChannelId> CreateChannelId(::flatbuffers::FlatBufferBuilder &_fbb, const TChannelId *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TChannelInfo : public ::flatbuffers::NativeTable {
  typedef ChannelInfo TableType;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "bluefish444.TChannelInfo";
  }
  std::unique_ptr<bluefish444::TDeviceId> device{};
  std::unique_ptr<bluefish444::TChannelId> channel{};
  std::string video_mode_name{};
  int32_t video_mode = 0;
  TChannelInfo() = default;
  TChannelInfo(const TChannelInfo &o);
  TChannelInfo(TChannelInfo&&) FLATBUFFERS_NOEXCEPT = default;
  TChannelInfo &operator=(TChannelInfo o) FLATBUFFERS_NOEXCEPT;
};

struct ChannelInfo FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TChannelInfo NativeTableType;
  typedef ChannelInfoBuilder Builder;
  struct Traits;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ChannelInfoTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "bluefish444.ChannelInfo";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DEVICE = 4,
    VT_CHANNEL = 6,
    VT_VIDEO_MODE_NAME = 8,
    VT_VIDEO_MODE = 10
  };
  const bluefish444::DeviceId *device() const {
    return GetPointer<const bluefish444::DeviceId *>(VT_DEVICE);
  }
  bluefish444::DeviceId *mutable_device() {
    return GetPointer<bluefish444::DeviceId *>(VT_DEVICE);
  }
  const bluefish444::ChannelId *channel() const {
    return GetPointer<const bluefish444::ChannelId *>(VT_CHANNEL);
  }
  bluefish444::ChannelId *mutable_channel() {
    return GetPointer<bluefish444::ChannelId *>(VT_CHANNEL);
  }
  const ::flatbuffers::String *video_mode_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_VIDEO_MODE_NAME);
  }
  ::flatbuffers::String *mutable_video_mode_name() {
    return GetPointer<::flatbuffers::String *>(VT_VIDEO_MODE_NAME);
  }
  int32_t video_mode() const {
    return GetField<int32_t>(VT_VIDEO_MODE, 0);
  }
  bool mutate_video_mode(int32_t _video_mode = 0) {
    return SetField<int32_t>(VT_VIDEO_MODE, _video_mode, 0);
  }
  template<size_t Index>
  auto get_field() const {
         if constexpr (Index == 0) return device();
    else if constexpr (Index == 1) return channel();
    else if constexpr (Index == 2) return video_mode_name();
    else if constexpr (Index == 3) return video_mode();
    else static_assert(Index != Index, "Invalid Field Index");
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DEVICE) &&
           verifier.VerifyTable(device()) &&
           VerifyOffset(verifier, VT_CHANNEL) &&
           verifier.VerifyTable(channel()) &&
           VerifyOffset(verifier, VT_VIDEO_MODE_NAME) &&
           verifier.VerifyString(video_mode_name()) &&
           VerifyField<int32_t>(verifier, VT_VIDEO_MODE, 4) &&
           verifier.EndTable();
  }
  TChannelInfo *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TChannelInfo *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<ChannelInfo> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TChannelInfo* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ChannelInfoBuilder {
  typedef ChannelInfo Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_device(::flatbuffers::Offset<bluefish444::DeviceId> device) {
    fbb_.AddOffset(ChannelInfo::VT_DEVICE, device);
  }
  void add_channel(::flatbuffers::Offset<bluefish444::ChannelId> channel) {
    fbb_.AddOffset(ChannelInfo::VT_CHANNEL, channel);
  }
  void add_video_mode_name(::flatbuffers::Offset<::flatbuffers::String> video_mode_name) {
    fbb_.AddOffset(ChannelInfo::VT_VIDEO_MODE_NAME, video_mode_name);
  }
  void add_video_mode(int32_t video_mode) {
    fbb_.AddElement<int32_t>(ChannelInfo::VT_VIDEO_MODE, video_mode, 0);
  }
  explicit ChannelInfoBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ChannelInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ChannelInfo>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ChannelInfo> CreateChannelInfo(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<bluefish444::DeviceId> device = 0,
    ::flatbuffers::Offset<bluefish444::ChannelId> channel = 0,
    ::flatbuffers::Offset<::flatbuffers::String> video_mode_name = 0,
    int32_t video_mode = 0) {
  ChannelInfoBuilder builder_(_fbb);
  builder_.add_video_mode(video_mode);
  builder_.add_video_mode_name(video_mode_name);
  builder_.add_channel(channel);
  builder_.add_device(device);
  return builder_.Finish();
}

struct ChannelInfo::Traits {
  using type = ChannelInfo;
  static auto constexpr Create = CreateChannelInfo;
  static constexpr auto name = "ChannelInfo";
  static constexpr auto fully_qualified_name = "bluefish444.ChannelInfo";
  static constexpr size_t fields_number = 4;
  static constexpr std::array<const char *, fields_number> field_names = {
    "device",
    "channel",
    "video_mode_name",
    "video_mode"
  };
  template<size_t Index>
  using FieldType = decltype(std::declval<type>().get_field<Index>());
};

inline ::flatbuffers::Offset<ChannelInfo> CreateChannelInfoDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<bluefish444::DeviceId> device = 0,
    ::flatbuffers::Offset<bluefish444::ChannelId> channel = 0,
    const char *video_mode_name = nullptr,
    int32_t video_mode = 0) {
  auto video_mode_name__ = video_mode_name ? _fbb.CreateString(video_mode_name) : 0;
  return bluefish444::CreateChannelInfo(
      _fbb,
      device,
      channel,
      video_mode_name__,
      video_mode);
}

::flatbuffers::Offset<ChannelInfo> CreateChannelInfo(::flatbuffers::FlatBufferBuilder &_fbb, const TChannelInfo *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);


inline bool operator==(const TDeviceId &lhs, const TDeviceId &rhs) {
  return
      (lhs.serial == rhs.serial) &&
      (lhs.name == rhs.name);
}

inline bool operator!=(const TDeviceId &lhs, const TDeviceId &rhs) {
    return !(lhs == rhs);
}


inline TDeviceId *DeviceId::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<TDeviceId>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void DeviceId::UnPackTo(TDeviceId *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = serial(); if (_e) _o->serial = _e->str(); }
  { auto _e = name(); if (_e) _o->name = _e->str(); }
}

inline ::flatbuffers::Offset<DeviceId> DeviceId::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TDeviceId* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDeviceId(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<DeviceId> CreateDeviceId(::flatbuffers::FlatBufferBuilder &_fbb, const TDeviceId *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const TDeviceId* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _serial = _o->serial.empty() ? 0 : _fbb.CreateString(_o->serial);
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  return bluefish444::CreateDeviceId(
      _fbb,
      _serial,
      _name);
}


inline bool operator==(const TChannelId &lhs, const TChannelId &rhs) {
  return
      (lhs.id == rhs.id) &&
      (lhs.name == rhs.name);
}

inline bool operator!=(const TChannelId &lhs, const TChannelId &rhs) {
    return !(lhs == rhs);
}


inline TChannelId *ChannelId::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<TChannelId>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ChannelId::UnPackTo(TChannelId *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); _o->id = _e; }
  { auto _e = name(); if (_e) _o->name = _e->str(); }
}

inline ::flatbuffers::Offset<ChannelId> ChannelId::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TChannelId* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateChannelId(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<ChannelId> CreateChannelId(::flatbuffers::FlatBufferBuilder &_fbb, const TChannelId *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const TChannelId* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _o->id;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  return bluefish444::CreateChannelId(
      _fbb,
      _id,
      _name);
}


inline bool operator==(const TChannelInfo &lhs, const TChannelInfo &rhs) {
  return
      ((lhs.device == rhs.device) || (lhs.device && rhs.device && *lhs.device == *rhs.device)) &&
      ((lhs.channel == rhs.channel) || (lhs.channel && rhs.channel && *lhs.channel == *rhs.channel)) &&
      (lhs.video_mode_name == rhs.video_mode_name) &&
      (lhs.video_mode == rhs.video_mode);
}

inline bool operator!=(const TChannelInfo &lhs, const TChannelInfo &rhs) {
    return !(lhs == rhs);
}


inline TChannelInfo::TChannelInfo(const TChannelInfo &o)
      : device((o.device) ? new bluefish444::TDeviceId(*o.device) : nullptr),
        channel((o.channel) ? new bluefish444::TChannelId(*o.channel) : nullptr),
        video_mode_name(o.video_mode_name),
        video_mode(o.video_mode) {
}

inline TChannelInfo &TChannelInfo::operator=(TChannelInfo o) FLATBUFFERS_NOEXCEPT {
  std::swap(device, o.device);
  std::swap(channel, o.channel);
  std::swap(video_mode_name, o.video_mode_name);
  std::swap(video_mode, o.video_mode);
  return *this;
}

inline TChannelInfo *ChannelInfo::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<TChannelInfo>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ChannelInfo::UnPackTo(TChannelInfo *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = device(); if (_e) { if(_o->device) { _e->UnPackTo(_o->device.get(), _resolver); } else { _o->device = std::unique_ptr<bluefish444::TDeviceId>(_e->UnPack(_resolver)); } } else if (_o->device) { _o->device.reset(); } }
  { auto _e = channel(); if (_e) { if(_o->channel) { _e->UnPackTo(_o->channel.get(), _resolver); } else { _o->channel = std::unique_ptr<bluefish444::TChannelId>(_e->UnPack(_resolver)); } } else if (_o->channel) { _o->channel.reset(); } }
  { auto _e = video_mode_name(); if (_e) _o->video_mode_name = _e->str(); }
  { auto _e = video_mode(); _o->video_mode = _e; }
}

inline ::flatbuffers::Offset<ChannelInfo> ChannelInfo::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TChannelInfo* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateChannelInfo(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<ChannelInfo> CreateChannelInfo(::flatbuffers::FlatBufferBuilder &_fbb, const TChannelInfo *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const TChannelInfo* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _device = _o->device ? CreateDeviceId(_fbb, _o->device.get(), _rehasher) : 0;
  auto _channel = _o->channel ? CreateChannelId(_fbb, _o->channel.get(), _rehasher) : 0;
  auto _video_mode_name = _o->video_mode_name.empty() ? 0 : _fbb.CreateString(_o->video_mode_name);
  auto _video_mode = _o->video_mode;
  return bluefish444::CreateChannelInfo(
      _fbb,
      _device,
      _channel,
      _video_mode_name,
      _video_mode);
}

inline const ::flatbuffers::TypeTable *DeviceIdTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_STRING, 0, -1 }
  };
  static const char * const names[] = {
    "serial",
    "name"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *ChannelIdTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_INT, 0, -1 },
    { ::flatbuffers::ET_STRING, 0, -1 }
  };
  static const char * const names[] = {
    "id",
    "name"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *ChannelInfoTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_SEQUENCE, 0, 1 },
    { ::flatbuffers::ET_STRING, 0, -1 },
    { ::flatbuffers::ET_INT, 0, -1 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    bluefish444::DeviceIdTypeTable,
    bluefish444::ChannelIdTypeTable
  };
  static const char * const names[] = {
    "device",
    "channel",
    "video_mode_name",
    "video_mode"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 4, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

}  // namespace bluefish444

#endif  // FLATBUFFERS_GENERATED_BLUEFISHTYPES_BLUEFISH444_H_
